//
// build.gradle in TeamCode
//
// Most of the definitions for building your module reside in a common, shared
// file 'build.common.gradle'. Being factored in this way makes it easier to
// integrate updates to the FTC into your code. If you really need to customize
// the build definitions, you can place those customizations in this file, but
// please think carefully as to whether such customizations are really necessary
// before doing so.


// Custom definitions may go here

// Include common definitions from above.
apply from: '../build.common.gradle'
apply from: '../build.dependencies.gradle'

apply plugin: 'org.jlleitschuh.gradle.ktlint'
apply plugin: 'org.mozilla.rust-android-gradle.rust-android'

configurations {
    tensorflowLite
    // ftc265Headers
}

dependencies {
    implementation project(':FtcRobotController')
    annotationProcessor files('lib/OpModeAnnotationProcessor.jar')

    implementation 'com.acmerobotics.roadrunner:core:0.5.2'
    implementation 'com.acmerobotics.dashboard:dashboard:0.3.10'

    implementation "org.joml:joml:1.10.1"

    implementation 'org.openftc:easyopencv:1.5.0'
    implementation 'org.openftc:rev-extensions-2:1.2'

    tensorflowLite(implementation("org.tensorflow:tensorflow-lite:2.4.0"))

    implementation "org.apache.commons:commons-math3:3.6.1"

    implementation "com.noahbres.jotai:jotai:1.0.2"

    implementation 'com.spartronics4915.lib:ftc265:3.0.0'
    implementation files('lib/ftc265-3.0.0-pre.5.aar')
    implementation 'com.intel.realsense:librealsense:2.41.1-ftc265@aar'
    // ftc265Headers "com.intel.realsense:librealsense:2.41.1-ftc265@zip"
}

// Extract the tensorflow library for linking
tasks.register('extractTensorflowLiteJni', Sync) {
    dependsOn configurations.tensorflowLite
    from {
        configurations.tensorflowLite.collect {
            zipTree(it).matching {
                include "jni/armeabi-v7a/**"
            }.singleFile
        }
    } {
        rename { 'libtensorflow-lite.so' }
    }
    into new File(project.rootProject.projectDir, 'ProjectTomato/target/tensorflowLite')
}

// Extract the ftc265 headers so we can use bindgen on them
// tasks.register('extractFTC265Headers', Sync) {
//     dependsOn configurations.ftc265Headers
//     from { configurations.ftc265Headers.collect { zipTree(it) } }
//     into new File(project.rootProject.projectDir, "ProjectTomato/target/ftc265")
// }

// Add our native code
cargo {
    module  =  "../ProjectTomato"
    libname = "tomato"
    targets = ["arm"]

    exec { spec, toolchain ->
        // opencv environment
        def openCVRoot = new File(project.rootProject.projectDir, "ProjectTomato/OpenCV-Repackaged/doc/")
        spec.environment("OPENCV_LINK_LIBS", "OpenCvAndroid453")
        spec.environment("OPENCV_LINK_PATHS", new File(openCVRoot, "native_libs/armeabi-v7a").getAbsolutePath())
        spec.environment("OPENCV_INCLUDE_PATHS", new File(openCVRoot, "native_headers").getAbsolutePath())
        spec.environment("OPENCV_CLANG_TARGET", "armv7a-unknown-linux-android$android.defaultConfig.minSdkVersion.mApiLevel")
        // These modules are nonexistent on Android
        spec.environment("OPENCV_MODULE_BLACKLIST", "gapi,highgui,stitching,videoio")

        // tflite environment
        spec.environment("TFLITE_LIB_DIR", tasks['extractTensorflowLiteJni'].outputs.files.singleFile)
        spec.environment("OPENCV_MODULE_BLACKLIST", "gapi,highgui,stitching")
        spec.environment("RUST_BACKTRACE", "1")
    }
}

tasks.whenTaskAdded {
    if ((it.name == 'javaPreCompileDebug' || it.name == 'javaPreCompileRelease')) {
        it.dependsOn 'cargoBuild'
    }
    if (it.name.startsWith('cargoBuild')) {
        it.dependsOn 'extractTensorflowLiteJni'
        // it.dependsOn 'extractFTC265Headers'
    }
}

ktlint {
    disabledRules = ["no-wildcard-imports"]
}
